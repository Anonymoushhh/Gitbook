## 工作流程

![](/assets/import.png)

### NameServer Cluster：名称服务集群。
&emsp;&emsp;它就是一个服务注册中心。NameServer就类似于商场中的商品查询机器，它里面存储着所有商品的分类，每个分类所在的货架号等信息。

1. NameServer稳定性很高。假设一个商场中有多台商品查询机器，它们之间相互独立。即使一台机器挂了，顾客依然可以从其它机器上查询商品；但若所有的查询机器都挂了，那么已经查询到信息的顾客仍然可以记住之前查询到的商品所在货架，但若想添加商品或新来的顾客就无法获得服务了。
2. NameServer所对应的压力不会太大。假设每个货架都有感知自己商品变化的功能，每隔30秒该货架就要向商品查询机器发送自己的商品信息（种类，数量等等，也就是RocketMQ中的Topic），我们美名其曰把这个消息叫做“心跳”。每个货架每隔30秒就要向查询机器发送自己的“心跳”，一方面为了更新机器中自己的信息，另一方面告诉机器自己还“活着”。

### Broker Cluster：代理服务集群。
&emsp;&emsp;它可能是整个消息中间件中最重要的模块了，Broker的作用类似于“货架”。试想一个商场要是没有货架和商品的话其它的东西还有什么意义呢？

1. 商场的工作人员将货物放置在某个货架上，当顾客满怀期待的来到该货架时，货架就将顾客需要的商品交付给他，这就是传说中的“PULL”模式；
2. 而当工作人员把商品摆好之后，看了下记录的手册，发现A顾客之前“订阅”了该商品，于是主动通知A来取（消费）该商品，这就是“PUSH”模式。

如上图所示，每个Broker可以有一台备份货架，上面存储的内容与主货架一致，当主货架发生意外时，可以切换到备用货架。

那么问题又来了，店员发现某个货架“挂了”，于是赶紧去恢复它，那如何知道它之前的商品有哪些呢？

&emsp;&emsp;幸运的是，RocketMQ早已替我们想到了这一点，它将所有商品的信息记录在一张表上，我们只需要翻阅这张“表”（硬盘），就可以知道它之前的所有商品信息。

&emsp;&emsp;另外，我们可能会注意到，在商场购买商品时，货架上的商品往往是“有序摆放”的。原因有很多，比如店员可能向先卖掉排在前面的商品（比如它快过期了...）RocketMQ也可以保证商品被购买的有序性，不过这个有序性是局部的，也就是对于单个货架的，因为我们不可能对不同货架上的商品进行排序，这也不符合常理。

### Producer Cluster：生产者集群。

&emsp;&emsp;当店员要进行补货时，先去商品查询机器（NameServer）查询要补货的商品（Topic）在哪些broker中（这里要建立一个长连接，店员为了防止每次都去查询机器查询（这样可能会妨碍其他顾客使用），就每30秒查询一次，并将商品和货架的关系更新到本地内存中）。当店员知道了要补货的商品所在货架后，就可以去对应货架补货了（这里也建立一个长连接，店员每30秒发送一个“心跳”包，确保让货架知道自己没有下班，货架也会每10秒扫描一次在它这里注册的店员，若2分钟内该店员都没有“心跳”，则他可能是”下班“了）。

### Consumer Cluster：消费者集群。

&emsp;&emsp;顾客的行为与店员是类似的。当顾客要买某个商品时先去查询机器查询，同时要跟该机器建立长连接（心跳机制与生产者的相同）。顾客知道了对应的货架，可以去主动取得商品（对应于“PULL”模式），当然，它也可以订阅该商品，当商品到货时等着货架通知他。


