简介

RocketMQ是阿里基于开源思想做的一款产品，它作为一款纯java、分布式、队列模型的开源消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。

概述

RocketMQ由四个部分组成：NameServer Cluster，Broker Cluster，Producer Cluster，Consumer Cluster，他们都可以水平扩展避免单点故障。

工作流程

NameServer Cluster：名称服务集群。它就是一个服务注册中心。NameServer就类似于商场中的商品查询机器，它里面存储着所有商品的分类，每个分类所在的货架号等信息。

1.NameServer稳定性很高。假设一个商场中有多台商品查询机器，它们之间相互独立。即使一台机器挂了，顾客依然可以从其它机器上查询商品；但若所有的查询机器都挂了，那么已经查询到信息的顾客仍然可以记住之前查询到的商品所在货架，但若想添加商品或新来的顾客就无法获得服务了。

2.NameServer所对应的压力不会太大。假设每个货架都有感知自己商品变化的功能，每隔30秒该货架就要向商品查询机器发送自己的商品信息（种类，数量等等，也就是RocketMQ中的Topic），我们美名其曰把这个消息叫做“心跳”。每个货架每隔30秒就要向查询机器发送自己的“心跳”，一方面为了更新机器中自己的信息，另一方面告诉机器自己还“活着”。

Broker Cluster：代理服务集群。它可能是整个消息中间件中最重要的模块了，试想一个商场要是没有货架和商品的话其它的东西还有什么意义呢？

Broker的作用类似于“货架”。

1.商场的工作人员将货物放置在某个货架上，当顾客满怀期待的来到该货架时，货架就将顾客需要的商品交付给他，这就是传说中的“PULL”模式；

2.而当工作人员把商品摆好之后，看了下记录的手册，发现A顾客之前”订阅“了该商品，于是主动通知A来取（消费）该商品，这就是“PUSH”模式。

Broker为了保证高可用性，提供了一系列机制。

现在我们来设想一个极端的情况：假设每个货架上的商品是“可被损坏的”，比如突然这个货架里的商品都被偷走了，或者货架上的商品被一个调皮的小孩弄坏了，此时顾客满怀欣喜的来到商场，却发现要买的商品被“损坏”了，他心里十分不爽，决定以后再也不来这家商场了，这就造成了很差的用户体验。于是RocketMQ提供了“主从同步机制”（HA），这里主又叫“Master”，从又叫“Slave”。我们可以用4种方式部署集群：

1.单Master模式

该模式就是单机模式，若该节点挂掉，整个“商场”的服务将不可用。

2.多Master模式

该模式有点像Java的J.U.C包中ConcurrentHashMap的思想，即把数据“分段”。单个节点挂掉后，受到影响的只有这台机器上的商品，这保证了大部分商品可继续售卖。

3.多Master多Slave（异步复制模式）

试想每个货架都有一个备份货架，平时顾客购买商品时都从Master货架上取，然后异步更新到Slave货架上，当突然有一天Master不可用了，顾客仍然可以在Slave货架上买到一样的商品。但由于是弱一致性，这会丢失少量的信息。

4.多Master多Slave（同步复制模式）

形式与3一样，只不过Master更新时同时更新Slave，保证了强一致性，这样若Master突然挂掉，其对应的Slave货架仍然可以完美的替代它，不会出现任何信息丢失，只不过性能会比异步复制低10%左右。

那么问题又来了，店员发现某个货架“挂了”，于是赶紧去恢复它，那如何知道它之前的商品有哪些呢？

幸运的是，RocketMQ早已替我们想到了这一点，它将所有商品的信息记录在一张表上，我们只需要翻阅这张“表”（硬盘），就可以知道它之前的所有商品信息。

另外，我们可能会注意到，在商场购买商品时，货架上的商品往往是“有序摆放”的。原因有很多，比如店员可能向先卖掉排在前面的商品（比如它快过期了...）RocketMQ也可以保证商品被购买的有序性，不过这个有序性是局部的，也就是对于单个货架的，因为我们不可能对不同货架上的商品进行排序，这也不符合常理。

Producer Cluster：生产者集群。当店员要进行补货时，先去商品查询机器（NameServer）查询要补货的商品（Topic）在哪些broker中（这里要建立一个长连接，店员为了防止每次都去查询机器查询（这样可能会妨碍其他顾客使用），就每30秒查询一次，并将商品和货架的关系更新到本地内存中）。当店员知道了要补货的商品所在货架后，就可以去对应货架补货了（这里也建立一个长连接，店员每30秒发送一个“心跳”包，确保让货架知道自己没有下班，货架也会每10秒扫描一次在它这里注册的店员，若2分钟内该店员都没有“心跳”，则他可能是”下班“了）。

Consumer Cluster：消费者集群。顾客的行为与店员是类似的。当顾客要买某个商品时先去查询机器查询，同时要跟该机器建立长连接（心跳机制与生产者的相同）。顾客知道了对应的货架，可以去主动取得商品（对应于“PULL”模式），当然，它也可以订阅该商品，当商品到货时等着货架通知他。



