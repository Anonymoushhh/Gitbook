##场景
&emsp;&emsp;现在系统流行微服务架构，假设购买商品时需要有两个操作，分别是扣库存和记录购买行为。然而扣库存操作的商品表在商品系统中，记录购买行为的订单表在订单系统中，两个系统数据库分离。为了保证服务的可靠性，我们要确保这两个操作为一个事务，要么都成功，要么都失败。在分布式环境下，根据CAP理论，我们总要舍弃点什么。在这种情况下，P（Partition tolerance）往往是不可避免的，因为网络问题总是不稳定的。因此可以认为 CAP 的 P 总是成立，而CAP 定理告诉我们，剩下的 C（Consistency）和 A（vailability） 无法同时做到。
##分析
&emsp;&emsp;在分布式环境中，我们需要保证的是一致性，而抛弃可用性。而一致性又分为强一致性，弱一致性和最终一致性。保证强一致性往往需要付出惨重的代价，比如系统运行缓慢，甚至死锁，因此我们有些情况下只需保证事务的最终一致性即可。
##方案
&emsp;&emsp;A（存在DB操作）、B（存在DB操作）两方需要保证分布式事务一致性，通过引入中间层MQ，A和MQ保持事务一致性（异常情况下通过MQ反查A接口实现check），B和MQ保证事务一致（通过重试），从而达到最终事务一致性。其中的原理就是：大事务 = 小事务 + 异步。
![](/assets/shiwu.png)
&emsp;&emsp;首先商品数据库向MQ服务器请求开启A事务，收到ACK后开始执行A事务，执行完毕后请求开启B事务，此时A事务已经完成，若收到ACK则商品DB就认为B事务执行完成（即使还没有完成），接下来的操作就由MQ异步去执行。MQ向订单DB发送开启B事务的请求，B事务开始执行，然后提交后向MQ发送执行完成的消息，MQ收到ACK才认为B事务完成，否则它会不断的发送SYN，直到收到ACK。但这里要注意保证订单DB消费的幂等性，因为订单DB发送的ACK可能丢失，因此MQ可能会向订单DB发送多个SYN。
##问题
&emsp;&emsp;以为这样就万事大吉了？想象一种情况，B事务因为某种原因一直无法执行成功，也就是库存已经扣了，一天一夜之后订单信息也没记录成功，这时是不是应该回滚？如何回滚？阿里提供给我们的解决方法是：人工解决。大家可以考虑一下，按照事务的流程，因为某种原因记录购买行为失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。这也是RocketMQ目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。因此RocketMQ在3.2.6版本中移除了事务消息的实现，所以此版本不支持事务消息。