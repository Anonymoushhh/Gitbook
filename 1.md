Netty 是一个网络应用框架，或者说是一个 Java 网络开发库。 Netty 提供异
步事件驱动的方式，使用它可以快速地开发出高性能的网络应用程序，比如客
户端／服务器自定义协议程序，大大简化了网络程序的开发过程。
Netty 是一个精心设计的框架，它从许多协议实现中吸收了丰富的经验，比 如 FTP, SMTP、 HTTP 等许多基于二进制和文本的传统协议。 借助 Netty，可 以比较容易地开发出达到 Java 网络专家＋并发编程专家水平的通信程序。
RocketMQ 底层通信的 实 现是在 Remoting 模块里，因为借助了 Netty ,
RocketMQ 的通信部分没有很多的代码，就是用 Netty 实现了一个自定义协议 的客户端 ／ 服务器程序。
###顶层抽象类
RocketMQ 的通信部分代码量并不多， 代码结构如图所示。
![](/assets/QQ截图20190503153153.jpg)
RocketMQ 通信模块的顶层结构是 RemotingServer 和 RemotingClient，分
别对应通信的服务端和客户端。 首先看看 RemotingServer：
![](/assets/QQ截图20190503153307.jpg)![](/assets/QQ截图20190503153315.jpg)
RemotingServer 类 中比较重要的是： localListenPort、 registerProcessor 和
registerDefaultProcessor, registerDefaultProcessor 用来设置接收到消息后的处
理方法。
RemotingClient 类 和 RemotingServer 类 相对应， 比 较 重要的方 法是
updateN ameServer AddressList、 invokeSync 和 invokeOneway , updateName
ServerAddressList 用来获取有效的 NameServer 地址， invokeSync 与 invokeOneway
用来向 Server 端发送请求， 如代码清单 13-6 所示。
![](/assets/QQ截图20190503153409.jpg)
基于 Netty 的 Server 和 Client
基于 Netty 实现的 Server 或 Client 程序， 具体代码在 NettyRemotingServer
和 NettyRemotingClient 这两个类 中，我们从 ServerBootstrap 的初始化来 看
RocketMQ 是如何基于 Netty 实现 Server 端程序的，如代码清单 13-10 所示。
![](/assets/QQ截图20190503153454.jpg)
ServerBootStrap 的 BossEventLoop 使用的是单线程 的 NioEventLoopGroup,
workerEventLoop 在 Linux 平台使用的是默认 3 个线程的 EpollEventLoopGroup,
因
仅限非商业用途或学习研究使用
152 令 RocketMQ 实战与原理解析
在非 Linux 平台使用的是 3 个线程 的 NioEventLoopGroup。 在最后几行代码
中还可以 看 到添加了 NettyEncoder 和 NettyDecoder 这 两个 Handler。 这些 Handler 执行在一个 8 线程的 DefaultEventExecutorGroup 中。
RocketMQ 对通信过程的另一个抽象是 Processor 和 Executor，当接收到一 个消息后 ， 直接根据消息的类型调用对应的 Processor 和 Executor，把通信过程 和业务逻辑分离开来。 我们通过一个 Broker 中的代码段来看看注册 Processor 的过程，如代码清单 13-11 所示。
![](/assets/QQ截图20190503153600.jpg)
注册 Processor 示例代码段来自 org.apache.rocketmq.broker 包中的 BrokerController 类，可以看出通过 RocketMQ 所做的抽象、 通信逻辑和信息处 理逻辑被分离开， 使结构变得非常清晰。
